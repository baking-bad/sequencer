// This file is generated by rust-protobuf 3.3.0. Do not edit
// .proto file is parsed by protoc --rust-out=...
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `crates/pre-block/proto/exporter.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_3_0;

// @@protoc_insertion_point(message:exporter.SubDag)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct SubDag {
    // message fields
    // @@protoc_insertion_point(field:exporter.SubDag.id)
    pub id: u64,
    // @@protoc_insertion_point(field:exporter.SubDag.leader)
    pub leader: ::protobuf::MessageField<Certificate>,
    // @@protoc_insertion_point(field:exporter.SubDag.certificates)
    pub certificates: ::std::vec::Vec<Certificate>,
    // @@protoc_insertion_point(field:exporter.SubDag.payloads)
    pub payloads: ::std::vec::Vec<Payload>,
    // special fields
    // @@protoc_insertion_point(special_field:exporter.SubDag.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SubDag {
    fn default() -> &'a SubDag {
        <SubDag as ::protobuf::Message>::default_instance()
    }
}

impl SubDag {
    pub fn new() -> SubDag {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &SubDag| { &m.id },
            |m: &mut SubDag| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Certificate>(
            "leader",
            |m: &SubDag| { &m.leader },
            |m: &mut SubDag| { &mut m.leader },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "certificates",
            |m: &SubDag| { &m.certificates },
            |m: &mut SubDag| { &mut m.certificates },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "payloads",
            |m: &SubDag| { &m.payloads },
            |m: &mut SubDag| { &mut m.payloads },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SubDag>(
            "SubDag",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SubDag {
    const NAME: &'static str = "SubDag";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.id = is.read_uint64()?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.leader)?;
                },
                26 => {
                    self.certificates.push(is.read_message()?);
                },
                34 => {
                    self.payloads.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.id != 0 {
            my_size += ::protobuf::rt::uint64_size(1, self.id);
        }
        if let Some(v) = self.leader.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.certificates {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.payloads {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.id != 0 {
            os.write_uint64(1, self.id)?;
        }
        if let Some(v) = self.leader.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        for v in &self.certificates {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        for v in &self.payloads {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SubDag {
        SubDag::new()
    }

    fn clear(&mut self) {
        self.id = 0;
        self.leader.clear();
        self.certificates.clear();
        self.payloads.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SubDag {
        static instance: SubDag = SubDag {
            id: 0,
            leader: ::protobuf::MessageField::none(),
            certificates: ::std::vec::Vec::new(),
            payloads: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SubDag {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SubDag").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SubDag {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SubDag {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:exporter.Certificate)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Certificate {
    // message fields
    // @@protoc_insertion_point(field:exporter.Certificate.header)
    pub header: ::protobuf::MessageField<Header>,
    // @@protoc_insertion_point(field:exporter.Certificate.signature)
    pub signature: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:exporter.Certificate.signers)
    pub signers: ::std::vec::Vec<u8>,
    // special fields
    // @@protoc_insertion_point(special_field:exporter.Certificate.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Certificate {
    fn default() -> &'a Certificate {
        <Certificate as ::protobuf::Message>::default_instance()
    }
}

impl Certificate {
    pub fn new() -> Certificate {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Header>(
            "header",
            |m: &Certificate| { &m.header },
            |m: &mut Certificate| { &mut m.header },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "signature",
            |m: &Certificate| { &m.signature },
            |m: &mut Certificate| { &mut m.signature },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "signers",
            |m: &Certificate| { &m.signers },
            |m: &mut Certificate| { &mut m.signers },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Certificate>(
            "Certificate",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Certificate {
    const NAME: &'static str = "Certificate";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.header)?;
                },
                18 => {
                    self.signature = is.read_bytes()?;
                },
                26 => {
                    self.signers = is.read_bytes()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.signature.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.signature);
        }
        if !self.signers.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.signers);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.header.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.signature.is_empty() {
            os.write_bytes(2, &self.signature)?;
        }
        if !self.signers.is_empty() {
            os.write_bytes(3, &self.signers)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Certificate {
        Certificate::new()
    }

    fn clear(&mut self) {
        self.header.clear();
        self.signature.clear();
        self.signers.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Certificate {
        static instance: Certificate = Certificate {
            header: ::protobuf::MessageField::none(),
            signature: ::std::vec::Vec::new(),
            signers: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Certificate {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Certificate").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Certificate {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Certificate {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:exporter.Header)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Header {
    // message fields
    // @@protoc_insertion_point(field:exporter.Header.author)
    pub author: u32,
    // @@protoc_insertion_point(field:exporter.Header.round)
    pub round: u64,
    // @@protoc_insertion_point(field:exporter.Header.epoch)
    pub epoch: u64,
    // @@protoc_insertion_point(field:exporter.Header.created_at)
    pub created_at: u64,
    // @@protoc_insertion_point(field:exporter.Header.payload_info)
    pub payload_info: ::std::vec::Vec<BatchInfo>,
    // @@protoc_insertion_point(field:exporter.Header.system_messages)
    pub system_messages: ::std::vec::Vec<SystemMessage>,
    // @@protoc_insertion_point(field:exporter.Header.parents)
    pub parents: ::std::vec::Vec<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:exporter.Header.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Header {
    fn default() -> &'a Header {
        <Header as ::protobuf::Message>::default_instance()
    }
}

impl Header {
    pub fn new() -> Header {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(7);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "author",
            |m: &Header| { &m.author },
            |m: &mut Header| { &mut m.author },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "round",
            |m: &Header| { &m.round },
            |m: &mut Header| { &mut m.round },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "epoch",
            |m: &Header| { &m.epoch },
            |m: &mut Header| { &mut m.epoch },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "created_at",
            |m: &Header| { &m.created_at },
            |m: &mut Header| { &mut m.created_at },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "payload_info",
            |m: &Header| { &m.payload_info },
            |m: &mut Header| { &mut m.payload_info },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "system_messages",
            |m: &Header| { &m.system_messages },
            |m: &mut Header| { &mut m.system_messages },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "parents",
            |m: &Header| { &m.parents },
            |m: &mut Header| { &mut m.parents },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Header>(
            "Header",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Header {
    const NAME: &'static str = "Header";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.author = is.read_uint32()?;
                },
                16 => {
                    self.round = is.read_uint64()?;
                },
                24 => {
                    self.epoch = is.read_uint64()?;
                },
                32 => {
                    self.created_at = is.read_uint64()?;
                },
                42 => {
                    self.payload_info.push(is.read_message()?);
                },
                50 => {
                    self.system_messages.push(is.read_message()?);
                },
                58 => {
                    self.parents.push(is.read_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.author != 0 {
            my_size += ::protobuf::rt::uint32_size(1, self.author);
        }
        if self.round != 0 {
            my_size += ::protobuf::rt::uint64_size(2, self.round);
        }
        if self.epoch != 0 {
            my_size += ::protobuf::rt::uint64_size(3, self.epoch);
        }
        if self.created_at != 0 {
            my_size += ::protobuf::rt::uint64_size(4, self.created_at);
        }
        for value in &self.payload_info {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.system_messages {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.parents {
            my_size += ::protobuf::rt::bytes_size(7, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.author != 0 {
            os.write_uint32(1, self.author)?;
        }
        if self.round != 0 {
            os.write_uint64(2, self.round)?;
        }
        if self.epoch != 0 {
            os.write_uint64(3, self.epoch)?;
        }
        if self.created_at != 0 {
            os.write_uint64(4, self.created_at)?;
        }
        for v in &self.payload_info {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        };
        for v in &self.system_messages {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        };
        for v in &self.parents {
            os.write_bytes(7, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Header {
        Header::new()
    }

    fn clear(&mut self) {
        self.author = 0;
        self.round = 0;
        self.epoch = 0;
        self.created_at = 0;
        self.payload_info.clear();
        self.system_messages.clear();
        self.parents.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Header {
        static instance: Header = Header {
            author: 0,
            round: 0,
            epoch: 0,
            created_at: 0,
            payload_info: ::std::vec::Vec::new(),
            system_messages: ::std::vec::Vec::new(),
            parents: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Header {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Header").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Header {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Header {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:exporter.BatchInfo)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct BatchInfo {
    // message fields
    // @@protoc_insertion_point(field:exporter.BatchInfo.digest)
    pub digest: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:exporter.BatchInfo.worker_id)
    pub worker_id: u32,
    // @@protoc_insertion_point(field:exporter.BatchInfo.created_at)
    pub created_at: u64,
    // special fields
    // @@protoc_insertion_point(special_field:exporter.BatchInfo.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a BatchInfo {
    fn default() -> &'a BatchInfo {
        <BatchInfo as ::protobuf::Message>::default_instance()
    }
}

impl BatchInfo {
    pub fn new() -> BatchInfo {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "digest",
            |m: &BatchInfo| { &m.digest },
            |m: &mut BatchInfo| { &mut m.digest },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "worker_id",
            |m: &BatchInfo| { &m.worker_id },
            |m: &mut BatchInfo| { &mut m.worker_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "created_at",
            |m: &BatchInfo| { &m.created_at },
            |m: &mut BatchInfo| { &mut m.created_at },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<BatchInfo>(
            "BatchInfo",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for BatchInfo {
    const NAME: &'static str = "BatchInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.digest = is.read_bytes()?;
                },
                16 => {
                    self.worker_id = is.read_uint32()?;
                },
                24 => {
                    self.created_at = is.read_uint64()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.digest.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.digest);
        }
        if self.worker_id != 0 {
            my_size += ::protobuf::rt::uint32_size(2, self.worker_id);
        }
        if self.created_at != 0 {
            my_size += ::protobuf::rt::uint64_size(3, self.created_at);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.digest.is_empty() {
            os.write_bytes(1, &self.digest)?;
        }
        if self.worker_id != 0 {
            os.write_uint32(2, self.worker_id)?;
        }
        if self.created_at != 0 {
            os.write_uint64(3, self.created_at)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> BatchInfo {
        BatchInfo::new()
    }

    fn clear(&mut self) {
        self.digest.clear();
        self.worker_id = 0;
        self.created_at = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static BatchInfo {
        static instance: BatchInfo = BatchInfo {
            digest: ::std::vec::Vec::new(),
            worker_id: 0,
            created_at: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for BatchInfo {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("BatchInfo").unwrap()).clone()
    }
}

impl ::std::fmt::Display for BatchInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BatchInfo {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:exporter.SystemMessage)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct SystemMessage {
    // message oneof groups
    pub message: ::std::option::Option<system_message::Message>,
    // special fields
    // @@protoc_insertion_point(special_field:exporter.SystemMessage.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SystemMessage {
    fn default() -> &'a SystemMessage {
        <SystemMessage as ::protobuf::Message>::default_instance()
    }
}

impl SystemMessage {
    pub fn new() -> SystemMessage {
        ::std::default::Default::default()
    }

    // bytes dkg_message = 1;

    pub fn dkg_message(&self) -> &[u8] {
        match self.message {
            ::std::option::Option::Some(system_message::Message::DkgMessage(ref v)) => v,
            _ => &[],
        }
    }

    pub fn clear_dkg_message(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_dkg_message(&self) -> bool {
        match self.message {
            ::std::option::Option::Some(system_message::Message::DkgMessage(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_dkg_message(&mut self, v: ::std::vec::Vec<u8>) {
        self.message = ::std::option::Option::Some(system_message::Message::DkgMessage(v))
    }

    // Mutable pointer to the field.
    pub fn mut_dkg_message(&mut self) -> &mut ::std::vec::Vec<u8> {
        if let ::std::option::Option::Some(system_message::Message::DkgMessage(_)) = self.message {
        } else {
            self.message = ::std::option::Option::Some(system_message::Message::DkgMessage(::std::vec::Vec::new()));
        }
        match self.message {
            ::std::option::Option::Some(system_message::Message::DkgMessage(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_dkg_message(&mut self) -> ::std::vec::Vec<u8> {
        if self.has_dkg_message() {
            match self.message.take() {
                ::std::option::Option::Some(system_message::Message::DkgMessage(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::vec::Vec::new()
        }
    }

    // bytes dkg_confirmation = 2;

    pub fn dkg_confirmation(&self) -> &[u8] {
        match self.message {
            ::std::option::Option::Some(system_message::Message::DkgConfirmation(ref v)) => v,
            _ => &[],
        }
    }

    pub fn clear_dkg_confirmation(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_dkg_confirmation(&self) -> bool {
        match self.message {
            ::std::option::Option::Some(system_message::Message::DkgConfirmation(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_dkg_confirmation(&mut self, v: ::std::vec::Vec<u8>) {
        self.message = ::std::option::Option::Some(system_message::Message::DkgConfirmation(v))
    }

    // Mutable pointer to the field.
    pub fn mut_dkg_confirmation(&mut self) -> &mut ::std::vec::Vec<u8> {
        if let ::std::option::Option::Some(system_message::Message::DkgConfirmation(_)) = self.message {
        } else {
            self.message = ::std::option::Option::Some(system_message::Message::DkgConfirmation(::std::vec::Vec::new()));
        }
        match self.message {
            ::std::option::Option::Some(system_message::Message::DkgConfirmation(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_dkg_confirmation(&mut self) -> ::std::vec::Vec<u8> {
        if self.has_dkg_confirmation() {
            match self.message.take() {
                ::std::option::Option::Some(system_message::Message::DkgConfirmation(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::vec::Vec::new()
        }
    }

    // .exporter.RandomnessSignature randomness_signature = 3;

    pub fn randomness_signature(&self) -> &RandomnessSignature {
        match self.message {
            ::std::option::Option::Some(system_message::Message::RandomnessSignature(ref v)) => v,
            _ => <RandomnessSignature as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_randomness_signature(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_randomness_signature(&self) -> bool {
        match self.message {
            ::std::option::Option::Some(system_message::Message::RandomnessSignature(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_randomness_signature(&mut self, v: RandomnessSignature) {
        self.message = ::std::option::Option::Some(system_message::Message::RandomnessSignature(v))
    }

    // Mutable pointer to the field.
    pub fn mut_randomness_signature(&mut self) -> &mut RandomnessSignature {
        if let ::std::option::Option::Some(system_message::Message::RandomnessSignature(_)) = self.message {
        } else {
            self.message = ::std::option::Option::Some(system_message::Message::RandomnessSignature(RandomnessSignature::new()));
        }
        match self.message {
            ::std::option::Option::Some(system_message::Message::RandomnessSignature(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_randomness_signature(&mut self) -> RandomnessSignature {
        if self.has_randomness_signature() {
            match self.message.take() {
                ::std::option::Option::Some(system_message::Message::RandomnessSignature(v)) => v,
                _ => panic!(),
            }
        } else {
            RandomnessSignature::new()
        }
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(1);
        fields.push(::protobuf::reflect::rt::v2::make_oneof_deref_has_get_set_simpler_accessor::<_, _>(
            "dkg_message",
            SystemMessage::has_dkg_message,
            SystemMessage::dkg_message,
            SystemMessage::set_dkg_message,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_deref_has_get_set_simpler_accessor::<_, _>(
            "dkg_confirmation",
            SystemMessage::has_dkg_confirmation,
            SystemMessage::dkg_confirmation,
            SystemMessage::set_dkg_confirmation,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, RandomnessSignature>(
            "randomness_signature",
            SystemMessage::has_randomness_signature,
            SystemMessage::randomness_signature,
            SystemMessage::mut_randomness_signature,
            SystemMessage::set_randomness_signature,
        ));
        oneofs.push(system_message::Message::generated_oneof_descriptor_data());
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SystemMessage>(
            "SystemMessage",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SystemMessage {
    const NAME: &'static str = "SystemMessage";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.message = ::std::option::Option::Some(system_message::Message::DkgMessage(is.read_bytes()?));
                },
                18 => {
                    self.message = ::std::option::Option::Some(system_message::Message::DkgConfirmation(is.read_bytes()?));
                },
                26 => {
                    self.message = ::std::option::Option::Some(system_message::Message::RandomnessSignature(is.read_message()?));
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.message {
            match v {
                &system_message::Message::DkgMessage(ref v) => {
                    my_size += ::protobuf::rt::bytes_size(1, &v);
                },
                &system_message::Message::DkgConfirmation(ref v) => {
                    my_size += ::protobuf::rt::bytes_size(2, &v);
                },
                &system_message::Message::RandomnessSignature(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let ::std::option::Option::Some(ref v) = self.message {
            match v {
                &system_message::Message::DkgMessage(ref v) => {
                    os.write_bytes(1, v)?;
                },
                &system_message::Message::DkgConfirmation(ref v) => {
                    os.write_bytes(2, v)?;
                },
                &system_message::Message::RandomnessSignature(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SystemMessage {
        SystemMessage::new()
    }

    fn clear(&mut self) {
        self.message = ::std::option::Option::None;
        self.message = ::std::option::Option::None;
        self.message = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SystemMessage {
        static instance: SystemMessage = SystemMessage {
            message: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SystemMessage {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SystemMessage").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SystemMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SystemMessage {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `SystemMessage`
pub mod system_message {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:exporter.SystemMessage.message)
    pub enum Message {
        // @@protoc_insertion_point(oneof_field:exporter.SystemMessage.dkg_message)
        DkgMessage(::std::vec::Vec<u8>),
        // @@protoc_insertion_point(oneof_field:exporter.SystemMessage.dkg_confirmation)
        DkgConfirmation(::std::vec::Vec<u8>),
        // @@protoc_insertion_point(oneof_field:exporter.SystemMessage.randomness_signature)
        RandomnessSignature(super::RandomnessSignature),
    }

    impl ::protobuf::Oneof for Message {
    }

    impl ::protobuf::OneofFull for Message {
        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| <super::SystemMessage as ::protobuf::MessageFull>::descriptor().oneof_by_name("message").unwrap()).clone()
        }
    }

    impl Message {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Message>("message")
        }
    }
}

// @@protoc_insertion_point(message:exporter.RandomnessSignature)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct RandomnessSignature {
    // message fields
    // @@protoc_insertion_point(field:exporter.RandomnessSignature.randomness_round)
    pub randomness_round: u64,
    // @@protoc_insertion_point(field:exporter.RandomnessSignature.bytes)
    pub bytes: ::std::vec::Vec<u8>,
    // special fields
    // @@protoc_insertion_point(special_field:exporter.RandomnessSignature.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a RandomnessSignature {
    fn default() -> &'a RandomnessSignature {
        <RandomnessSignature as ::protobuf::Message>::default_instance()
    }
}

impl RandomnessSignature {
    pub fn new() -> RandomnessSignature {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "randomness_round",
            |m: &RandomnessSignature| { &m.randomness_round },
            |m: &mut RandomnessSignature| { &mut m.randomness_round },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "bytes",
            |m: &RandomnessSignature| { &m.bytes },
            |m: &mut RandomnessSignature| { &mut m.bytes },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<RandomnessSignature>(
            "RandomnessSignature",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for RandomnessSignature {
    const NAME: &'static str = "RandomnessSignature";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.randomness_round = is.read_uint64()?;
                },
                18 => {
                    self.bytes = is.read_bytes()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.randomness_round != 0 {
            my_size += ::protobuf::rt::uint64_size(1, self.randomness_round);
        }
        if !self.bytes.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.bytes);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.randomness_round != 0 {
            os.write_uint64(1, self.randomness_round)?;
        }
        if !self.bytes.is_empty() {
            os.write_bytes(2, &self.bytes)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> RandomnessSignature {
        RandomnessSignature::new()
    }

    fn clear(&mut self) {
        self.randomness_round = 0;
        self.bytes.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static RandomnessSignature {
        static instance: RandomnessSignature = RandomnessSignature {
            randomness_round: 0,
            bytes: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for RandomnessSignature {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("RandomnessSignature").unwrap()).clone()
    }
}

impl ::std::fmt::Display for RandomnessSignature {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RandomnessSignature {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:exporter.Payload)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Payload {
    // message fields
    // @@protoc_insertion_point(field:exporter.Payload.batches)
    pub batches: ::std::vec::Vec<Batch>,
    // special fields
    // @@protoc_insertion_point(special_field:exporter.Payload.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Payload {
    fn default() -> &'a Payload {
        <Payload as ::protobuf::Message>::default_instance()
    }
}

impl Payload {
    pub fn new() -> Payload {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "batches",
            |m: &Payload| { &m.batches },
            |m: &mut Payload| { &mut m.batches },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Payload>(
            "Payload",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Payload {
    const NAME: &'static str = "Payload";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.batches.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.batches {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.batches {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Payload {
        Payload::new()
    }

    fn clear(&mut self) {
        self.batches.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Payload {
        static instance: Payload = Payload {
            batches: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Payload {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Payload").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Payload {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Payload {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:exporter.Batch)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Batch {
    // message fields
    // @@protoc_insertion_point(field:exporter.Batch.transactions)
    pub transactions: ::std::vec::Vec<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:exporter.Batch.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Batch {
    fn default() -> &'a Batch {
        <Batch as ::protobuf::Message>::default_instance()
    }
}

impl Batch {
    pub fn new() -> Batch {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "transactions",
            |m: &Batch| { &m.transactions },
            |m: &mut Batch| { &mut m.transactions },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Batch>(
            "Batch",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Batch {
    const NAME: &'static str = "Batch";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.transactions.push(is.read_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.transactions {
            my_size += ::protobuf::rt::bytes_size(1, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.transactions {
            os.write_bytes(1, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Batch {
        Batch::new()
    }

    fn clear(&mut self) {
        self.transactions.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Batch {
        static instance: Batch = Batch {
            transactions: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Batch {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Batch").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Batch {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Batch {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:exporter.ExportRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ExportRequest {
    // message fields
    // @@protoc_insertion_point(field:exporter.ExportRequest.from_id)
    pub from_id: u64,
    // special fields
    // @@protoc_insertion_point(special_field:exporter.ExportRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ExportRequest {
    fn default() -> &'a ExportRequest {
        <ExportRequest as ::protobuf::Message>::default_instance()
    }
}

impl ExportRequest {
    pub fn new() -> ExportRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "from_id",
            |m: &ExportRequest| { &m.from_id },
            |m: &mut ExportRequest| { &mut m.from_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ExportRequest>(
            "ExportRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ExportRequest {
    const NAME: &'static str = "ExportRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.from_id = is.read_uint64()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.from_id != 0 {
            my_size += ::protobuf::rt::uint64_size(1, self.from_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.from_id != 0 {
            os.write_uint64(1, self.from_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ExportRequest {
        ExportRequest::new()
    }

    fn clear(&mut self) {
        self.from_id = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ExportRequest {
        static instance: ExportRequest = ExportRequest {
            from_id: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ExportRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ExportRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ExportRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ExportRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n%crates/pre-block/proto/exporter.proto\x12\x08exporter\"\xb1\x01\n\x06\
    SubDag\x12\x0e\n\x02id\x18\x01\x20\x01(\x04R\x02id\x12-\n\x06leader\x18\
    \x02\x20\x01(\x0b2\x15.exporter.CertificateR\x06leader\x129\n\x0ccertifi\
    cates\x18\x03\x20\x03(\x0b2\x15.exporter.CertificateR\x0ccertificates\
    \x12-\n\x08payloads\x18\x04\x20\x03(\x0b2\x11.exporter.PayloadR\x08paylo\
    ads\"o\n\x0bCertificate\x12(\n\x06header\x18\x01\x20\x01(\x0b2\x10.expor\
    ter.HeaderR\x06header\x12\x1c\n\tsignature\x18\x02\x20\x01(\x0cR\tsignat\
    ure\x12\x18\n\x07signers\x18\x03\x20\x01(\x0cR\x07signers\"\xff\x01\n\
    \x06Header\x12\x16\n\x06author\x18\x01\x20\x01(\rR\x06author\x12\x14\n\
    \x05round\x18\x02\x20\x01(\x04R\x05round\x12\x14\n\x05epoch\x18\x03\x20\
    \x01(\x04R\x05epoch\x12\x1d\n\ncreated_at\x18\x04\x20\x01(\x04R\tcreated\
    At\x126\n\x0cpayload_info\x18\x05\x20\x03(\x0b2\x13.exporter.BatchInfoR\
    \x0bpayloadInfo\x12@\n\x0fsystem_messages\x18\x06\x20\x03(\x0b2\x17.expo\
    rter.SystemMessageR\x0esystemMessages\x12\x18\n\x07parents\x18\x07\x20\
    \x03(\x0cR\x07parents\"_\n\tBatchInfo\x12\x16\n\x06digest\x18\x01\x20\
    \x01(\x0cR\x06digest\x12\x1b\n\tworker_id\x18\x02\x20\x01(\rR\x08workerI\
    d\x12\x1d\n\ncreated_at\x18\x03\x20\x01(\x04R\tcreatedAt\"\xbe\x01\n\rSy\
    stemMessage\x12!\n\x0bdkg_message\x18\x01\x20\x01(\x0cH\0R\ndkgMessage\
    \x12+\n\x10dkg_confirmation\x18\x02\x20\x01(\x0cH\0R\x0fdkgConfirmation\
    \x12R\n\x14randomness_signature\x18\x03\x20\x01(\x0b2\x1d.exporter.Rando\
    mnessSignatureH\0R\x13randomnessSignatureB\t\n\x07message\"V\n\x13Random\
    nessSignature\x12)\n\x10randomness_round\x18\x01\x20\x01(\x04R\x0frandom\
    nessRound\x12\x14\n\x05bytes\x18\x02\x20\x01(\x0cR\x05bytes\"4\n\x07Payl\
    oad\x12)\n\x07batches\x18\x01\x20\x03(\x0b2\x0f.exporter.BatchR\x07batch\
    es\"+\n\x05Batch\x12\"\n\x0ctransactions\x18\x01\x20\x03(\x0cR\x0ctransa\
    ctions\"(\n\rExportRequest\x12\x17\n\x07from_id\x18\x01\x20\x01(\x04R\
    \x06fromId2C\n\x08Exporter\x127\n\x06Export\x12\x17.exporter.ExportReque\
    st\x1a\x10.exporter.SubDag\"\00\x01J\x8f\x10\n\x06\x12\x04\0\0<\x01\n\
    \x08\n\x01\x0c\x12\x03\0\0\x12\n\x08\n\x01\x02\x12\x03\x02\x08\x10\n\n\n\
    \x02\x04\0\x12\x04\x04\0\t\x01\n\n\n\x03\x04\0\x01\x12\x03\x04\x08\x0e\n\
    \x0b\n\x04\x04\0\x02\0\x12\x03\x05\x04\x12\n\r\n\x05\x04\0\x02\0\x04\x12\
    \x04\x05\x04\x04\x10\n\x0c\n\x05\x04\0\x02\0\x05\x12\x03\x05\x04\n\n\x0c\
    \n\x05\x04\0\x02\0\x01\x12\x03\x05\x0b\r\n\x0c\n\x05\x04\0\x02\0\x03\x12\
    \x03\x05\x10\x11\n\x0b\n\x04\x04\0\x02\x01\x12\x03\x06\x04\x1b\n\r\n\x05\
    \x04\0\x02\x01\x04\x12\x04\x06\x04\x05\x12\n\x0c\n\x05\x04\0\x02\x01\x06\
    \x12\x03\x06\x04\x0f\n\x0c\n\x05\x04\0\x02\x01\x01\x12\x03\x06\x10\x16\n\
    \x0c\n\x05\x04\0\x02\x01\x03\x12\x03\x06\x19\x1a\n\x0b\n\x04\x04\0\x02\
    \x02\x12\x03\x07\x04*\n\x0c\n\x05\x04\0\x02\x02\x04\x12\x03\x07\x04\x0c\
    \n\x0c\n\x05\x04\0\x02\x02\x06\x12\x03\x07\r\x18\n\x0c\n\x05\x04\0\x02\
    \x02\x01\x12\x03\x07\x19%\n\x0c\n\x05\x04\0\x02\x02\x03\x12\x03\x07()\n\
    \x0b\n\x04\x04\0\x02\x03\x12\x03\x08\x04\"\n\x0c\n\x05\x04\0\x02\x03\x04\
    \x12\x03\x08\x04\x0c\n\x0c\n\x05\x04\0\x02\x03\x06\x12\x03\x08\r\x14\n\
    \x0c\n\x05\x04\0\x02\x03\x01\x12\x03\x08\x15\x1d\n\x0c\n\x05\x04\0\x02\
    \x03\x03\x12\x03\x08\x20!\n\n\n\x02\x04\x01\x12\x04\x0b\0\x0f\x01\n\n\n\
    \x03\x04\x01\x01\x12\x03\x0b\x08\x13\n\x0b\n\x04\x04\x01\x02\0\x12\x03\
    \x0c\x04\x16\n\r\n\x05\x04\x01\x02\0\x04\x12\x04\x0c\x04\x0b\x15\n\x0c\n\
    \x05\x04\x01\x02\0\x06\x12\x03\x0c\x04\n\n\x0c\n\x05\x04\x01\x02\0\x01\
    \x12\x03\x0c\x0b\x11\n\x0c\n\x05\x04\x01\x02\0\x03\x12\x03\x0c\x14\x15\n\
    \x0b\n\x04\x04\x01\x02\x01\x12\x03\r\x04\x18\n\r\n\x05\x04\x01\x02\x01\
    \x04\x12\x04\r\x04\x0c\x16\n\x0c\n\x05\x04\x01\x02\x01\x05\x12\x03\r\x04\
    \t\n\x0c\n\x05\x04\x01\x02\x01\x01\x12\x03\r\n\x13\n\x0c\n\x05\x04\x01\
    \x02\x01\x03\x12\x03\r\x16\x17\n\x0b\n\x04\x04\x01\x02\x02\x12\x03\x0e\
    \x04\x16\n\r\n\x05\x04\x01\x02\x02\x04\x12\x04\x0e\x04\r\x18\n\x0c\n\x05\
    \x04\x01\x02\x02\x05\x12\x03\x0e\x04\t\n\x0c\n\x05\x04\x01\x02\x02\x01\
    \x12\x03\x0e\n\x11\n\x0c\n\x05\x04\x01\x02\x02\x03\x12\x03\x0e\x14\x15\n\
    \n\n\x02\x04\x02\x12\x04\x11\0\x19\x01\n\n\n\x03\x04\x02\x01\x12\x03\x11\
    \x08\x0e\n\x0b\n\x04\x04\x02\x02\0\x12\x03\x12\x04\x16\n\r\n\x05\x04\x02\
    \x02\0\x04\x12\x04\x12\x04\x11\x10\n\x0c\n\x05\x04\x02\x02\0\x05\x12\x03\
    \x12\x04\n\n\x0c\n\x05\x04\x02\x02\0\x01\x12\x03\x12\x0b\x11\n\x0c\n\x05\
    \x04\x02\x02\0\x03\x12\x03\x12\x14\x15\n\x0b\n\x04\x04\x02\x02\x01\x12\
    \x03\x13\x04\x15\n\r\n\x05\x04\x02\x02\x01\x04\x12\x04\x13\x04\x12\x16\n\
    \x0c\n\x05\x04\x02\x02\x01\x05\x12\x03\x13\x04\n\n\x0c\n\x05\x04\x02\x02\
    \x01\x01\x12\x03\x13\x0b\x10\n\x0c\n\x05\x04\x02\x02\x01\x03\x12\x03\x13\
    \x13\x14\n\x0b\n\x04\x04\x02\x02\x02\x12\x03\x14\x04\x15\n\r\n\x05\x04\
    \x02\x02\x02\x04\x12\x04\x14\x04\x13\x15\n\x0c\n\x05\x04\x02\x02\x02\x05\
    \x12\x03\x14\x04\n\n\x0c\n\x05\x04\x02\x02\x02\x01\x12\x03\x14\x0b\x10\n\
    \x0c\n\x05\x04\x02\x02\x02\x03\x12\x03\x14\x13\x14\n\x0b\n\x04\x04\x02\
    \x02\x03\x12\x03\x15\x04\x1a\n\r\n\x05\x04\x02\x02\x03\x04\x12\x04\x15\
    \x04\x14\x15\n\x0c\n\x05\x04\x02\x02\x03\x05\x12\x03\x15\x04\n\n\x0c\n\
    \x05\x04\x02\x02\x03\x01\x12\x03\x15\x0b\x15\n\x0c\n\x05\x04\x02\x02\x03\
    \x03\x12\x03\x15\x18\x19\n\x0b\n\x04\x04\x02\x02\x04\x12\x03\x16\x04(\n\
    \x0c\n\x05\x04\x02\x02\x04\x04\x12\x03\x16\x04\x0c\n\x0c\n\x05\x04\x02\
    \x02\x04\x06\x12\x03\x16\r\x16\n\x0c\n\x05\x04\x02\x02\x04\x01\x12\x03\
    \x16\x17#\n\x0c\n\x05\x04\x02\x02\x04\x03\x12\x03\x16&'\n\x0b\n\x04\x04\
    \x02\x02\x05\x12\x03\x17\x04/\n\x0c\n\x05\x04\x02\x02\x05\x04\x12\x03\
    \x17\x04\x0c\n\x0c\n\x05\x04\x02\x02\x05\x06\x12\x03\x17\r\x1a\n\x0c\n\
    \x05\x04\x02\x02\x05\x01\x12\x03\x17\x1b*\n\x0c\n\x05\x04\x02\x02\x05\
    \x03\x12\x03\x17-.\n\x0b\n\x04\x04\x02\x02\x06\x12\x03\x18\x04\x1f\n\x0c\
    \n\x05\x04\x02\x02\x06\x04\x12\x03\x18\x04\x0c\n\x0c\n\x05\x04\x02\x02\
    \x06\x05\x12\x03\x18\r\x12\n\x0c\n\x05\x04\x02\x02\x06\x01\x12\x03\x18\
    \x13\x1a\n\x0c\n\x05\x04\x02\x02\x06\x03\x12\x03\x18\x1d\x1e\n\n\n\x02\
    \x04\x03\x12\x04\x1b\0\x1f\x01\n\n\n\x03\x04\x03\x01\x12\x03\x1b\x08\x11\
    \n\x0b\n\x04\x04\x03\x02\0\x12\x03\x1c\x04\x15\n\r\n\x05\x04\x03\x02\0\
    \x04\x12\x04\x1c\x04\x1b\x13\n\x0c\n\x05\x04\x03\x02\0\x05\x12\x03\x1c\
    \x04\t\n\x0c\n\x05\x04\x03\x02\0\x01\x12\x03\x1c\n\x10\n\x0c\n\x05\x04\
    \x03\x02\0\x03\x12\x03\x1c\x13\x14\n\x0b\n\x04\x04\x03\x02\x01\x12\x03\
    \x1d\x04\x19\n\r\n\x05\x04\x03\x02\x01\x04\x12\x04\x1d\x04\x1c\x15\n\x0c\
    \n\x05\x04\x03\x02\x01\x05\x12\x03\x1d\x04\n\n\x0c\n\x05\x04\x03\x02\x01\
    \x01\x12\x03\x1d\x0b\x14\n\x0c\n\x05\x04\x03\x02\x01\x03\x12\x03\x1d\x17\
    \x18\n\x0b\n\x04\x04\x03\x02\x02\x12\x03\x1e\x04\x1a\n\r\n\x05\x04\x03\
    \x02\x02\x04\x12\x04\x1e\x04\x1d\x19\n\x0c\n\x05\x04\x03\x02\x02\x05\x12\
    \x03\x1e\x04\n\n\x0c\n\x05\x04\x03\x02\x02\x01\x12\x03\x1e\x0b\x15\n\x0c\
    \n\x05\x04\x03\x02\x02\x03\x12\x03\x1e\x18\x19\n\n\n\x02\x04\x04\x12\x04\
    !\0'\x01\n\n\n\x03\x04\x04\x01\x12\x03!\x08\x15\n\x0c\n\x04\x04\x04\x08\
    \0\x12\x04\"\x04&\x05\n\x0c\n\x05\x04\x04\x08\0\x01\x12\x03\"\n\x11\n\
    \x0b\n\x04\x04\x04\x02\0\x12\x03#\x08\x1e\n\x0c\n\x05\x04\x04\x02\0\x05\
    \x12\x03#\x08\r\n\x0c\n\x05\x04\x04\x02\0\x01\x12\x03#\x0e\x19\n\x0c\n\
    \x05\x04\x04\x02\0\x03\x12\x03#\x1c\x1d\n\x0b\n\x04\x04\x04\x02\x01\x12\
    \x03$\x08#\n\x0c\n\x05\x04\x04\x02\x01\x05\x12\x03$\x08\r\n\x0c\n\x05\
    \x04\x04\x02\x01\x01\x12\x03$\x0e\x1e\n\x0c\n\x05\x04\x04\x02\x01\x03\
    \x12\x03$!\"\n\x0b\n\x04\x04\x04\x02\x02\x12\x03%\x085\n\x0c\n\x05\x04\
    \x04\x02\x02\x06\x12\x03%\x08\x1b\n\x0c\n\x05\x04\x04\x02\x02\x01\x12\
    \x03%\x1c0\n\x0c\n\x05\x04\x04\x02\x02\x03\x12\x03%34\n\n\n\x02\x04\x05\
    \x12\x04)\0,\x01\n\n\n\x03\x04\x05\x01\x12\x03)\x08\x1b\n\x0b\n\x04\x04\
    \x05\x02\0\x12\x03*\x04\x20\n\r\n\x05\x04\x05\x02\0\x04\x12\x04*\x04)\
    \x1d\n\x0c\n\x05\x04\x05\x02\0\x05\x12\x03*\x04\n\n\x0c\n\x05\x04\x05\
    \x02\0\x01\x12\x03*\x0b\x1b\n\x0c\n\x05\x04\x05\x02\0\x03\x12\x03*\x1e\
    \x1f\n\x0b\n\x04\x04\x05\x02\x01\x12\x03+\x04\x14\n\r\n\x05\x04\x05\x02\
    \x01\x04\x12\x04+\x04*\x20\n\x0c\n\x05\x04\x05\x02\x01\x05\x12\x03+\x04\
    \t\n\x0c\n\x05\x04\x05\x02\x01\x01\x12\x03+\n\x0f\n\x0c\n\x05\x04\x05\
    \x02\x01\x03\x12\x03+\x12\x13\n\n\n\x02\x04\x06\x12\x04.\00\x01\n\n\n\
    \x03\x04\x06\x01\x12\x03.\x08\x0f\n\x0b\n\x04\x04\x06\x02\0\x12\x03/\x04\
    \x1f\n\x0c\n\x05\x04\x06\x02\0\x04\x12\x03/\x04\x0c\n\x0c\n\x05\x04\x06\
    \x02\0\x06\x12\x03/\r\x12\n\x0c\n\x05\x04\x06\x02\0\x01\x12\x03/\x13\x1a\
    \n\x0c\n\x05\x04\x06\x02\0\x03\x12\x03/\x1d\x1e\n\n\n\x02\x04\x07\x12\
    \x042\04\x01\n\n\n\x03\x04\x07\x01\x12\x032\x08\r\n\x0b\n\x04\x04\x07\
    \x02\0\x12\x033\x04$\n\x0c\n\x05\x04\x07\x02\0\x04\x12\x033\x04\x0c\n\
    \x0c\n\x05\x04\x07\x02\0\x05\x12\x033\r\x12\n\x0c\n\x05\x04\x07\x02\0\
    \x01\x12\x033\x13\x1f\n\x0c\n\x05\x04\x07\x02\0\x03\x12\x033\"#\n\n\n\
    \x02\x04\x08\x12\x046\08\x01\n\n\n\x03\x04\x08\x01\x12\x036\x08\x15\n\
    \x0b\n\x04\x04\x08\x02\0\x12\x037\x04\x17\n\r\n\x05\x04\x08\x02\0\x04\
    \x12\x047\x046\x17\n\x0c\n\x05\x04\x08\x02\0\x05\x12\x037\x04\n\n\x0c\n\
    \x05\x04\x08\x02\0\x01\x12\x037\x0b\x12\n\x0c\n\x05\x04\x08\x02\0\x03\
    \x12\x037\x15\x16\n\n\n\x02\x06\0\x12\x04:\0<\x01\n\n\n\x03\x06\0\x01\
    \x12\x03:\x08\x10\n\x0b\n\x04\x06\0\x02\0\x12\x03;\x048\n\x0c\n\x05\x06\
    \0\x02\0\x01\x12\x03;\x08\x0e\n\x0c\n\x05\x06\0\x02\0\x02\x12\x03;\x0f\
    \x1c\n\x0c\n\x05\x06\0\x02\0\x06\x12\x03;'-\n\x0c\n\x05\x06\0\x02\0\x03\
    \x12\x03;.4b\x06proto3\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: ::protobuf::rt::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static ::protobuf::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: ::protobuf::rt::Lazy<::protobuf::reflect::GeneratedFileDescriptor> = ::protobuf::rt::Lazy::new();
    static file_descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::FileDescriptor> = ::protobuf::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(0);
            let mut messages = ::std::vec::Vec::with_capacity(9);
            messages.push(SubDag::generated_message_descriptor_data());
            messages.push(Certificate::generated_message_descriptor_data());
            messages.push(Header::generated_message_descriptor_data());
            messages.push(BatchInfo::generated_message_descriptor_data());
            messages.push(SystemMessage::generated_message_descriptor_data());
            messages.push(RandomnessSignature::generated_message_descriptor_data());
            messages.push(Payload::generated_message_descriptor_data());
            messages.push(Batch::generated_message_descriptor_data());
            messages.push(ExportRequest::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(0);
            ::protobuf::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        ::protobuf::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}
